{
  "version": 3,
  "sources": ["../../../src/lib/utils/assets.ts"],
  "sourcesContent": ["import { isAnimated } from './is-gif-animated'\n\ntype BoxWidthHeight = {\n\tw: number\n\th: number\n}\n\n/**\n * Contains the size within the given box size\n *\n * @param originalSize - The size of the asset\n * @param containBoxSize - The container size\n * @returns Adjusted size\n * @public\n */\nexport function containBoxSize(\n\toriginalSize: BoxWidthHeight,\n\tcontainBoxSize: BoxWidthHeight\n): BoxWidthHeight {\n\tconst overByXScale = originalSize.w / containBoxSize.w\n\tconst overByYScale = originalSize.h / containBoxSize.h\n\n\tif (overByXScale <= 1 && overByYScale <= 1) {\n\t\treturn originalSize\n\t} else if (overByXScale > overByYScale) {\n\t\treturn {\n\t\t\tw: originalSize.w / overByXScale,\n\t\t\th: originalSize.h / overByXScale,\n\t\t}\n\t} else {\n\t\treturn {\n\t\t\tw: originalSize.w / overByYScale,\n\t\t\th: originalSize.h / overByYScale,\n\t\t}\n\t}\n}\n\n/**\n * Get the size of an image from its source.\n *\n * @param dataURLForImage - The image file as a string.\n * @param width - The desired width.\n * @param height - The desired height.\n * @public\n */\nexport async function getResizedImageDataUrl(\n\tdataURLForImage: string,\n\twidth: number,\n\theight: number\n): Promise<string> {\n\treturn await new Promise((resolve) => {\n\t\tconst img = new Image()\n\t\timg.onload = () => {\n\t\t\t// Initialize the canvas and it's size\n\t\t\tconst canvas = document.createElement('canvas')\n\t\t\tconst ctx = canvas.getContext('2d')\n\n\t\t\tif (!ctx) return\n\n\t\t\t// Set width and height\n\t\t\tcanvas.width = width * 2\n\t\t\tcanvas.height = height * 2\n\n\t\t\t// Draw image and export to a data-uri\n\t\t\tctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n\t\t\tconst newDataURL = canvas.toDataURL()\n\n\t\t\t// Do something with the result, like overwrite original\n\t\t\tresolve(newDataURL)\n\t\t}\n\t\timg.crossOrigin = 'anonymous'\n\t\timg.src = dataURLForImage\n\t})\n}\n\n/** @public */\nexport const DEFAULT_ACCEPTED_IMG_TYPE = ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml']\n/** @public */\nexport const DEFAULT_ACCEPTED_VID_TYPE = ['video/mp4', 'video/quicktime']\n\n/** @public */\nexport async function isGifAnimated(file: File): Promise<boolean> {\n\treturn await new Promise((resolve, reject) => {\n\t\tconst reader = new FileReader()\n\t\treader.onerror = () => reject(reader.error)\n\t\treader.onload = () => {\n\t\t\tresolve(reader.result ? isAnimated(reader.result as ArrayBuffer) : false)\n\t\t}\n\t\treader.readAsArrayBuffer(file)\n\t})\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAA2B;AAepB,SAAS,eACf,cACAA,iBACiB;AACjB,QAAM,eAAe,aAAa,IAAIA,gBAAe;AACrD,QAAM,eAAe,aAAa,IAAIA,gBAAe;AAErD,MAAI,gBAAgB,KAAK,gBAAgB,GAAG;AAC3C,WAAO;AAAA,EACR,WAAW,eAAe,cAAc;AACvC,WAAO;AAAA,MACN,GAAG,aAAa,IAAI;AAAA,MACpB,GAAG,aAAa,IAAI;AAAA,IACrB;AAAA,EACD,OAAO;AACN,WAAO;AAAA,MACN,GAAG,aAAa,IAAI;AAAA,MACpB,GAAG,aAAa,IAAI;AAAA,IACrB;AAAA,EACD;AACD;AAUA,eAAsB,uBACrB,iBACA,OACA,QACkB;AAClB,SAAO,MAAM,IAAI,QAAQ,CAAC,YAAY;AACrC,UAAM,MAAM,IAAI,MAAM;AACtB,QAAI,SAAS,MAAM;AAElB,YAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,YAAM,MAAM,OAAO,WAAW,IAAI;AAElC,UAAI,CAAC;AAAK;AAGV,aAAO,QAAQ,QAAQ;AACvB,aAAO,SAAS,SAAS;AAGzB,UAAI,UAAU,KAAK,GAAG,GAAG,OAAO,OAAO,OAAO,MAAM;AACpD,YAAM,aAAa,OAAO,UAAU;AAGpC,cAAQ,UAAU;AAAA,IACnB;AACA,QAAI,cAAc;AAClB,QAAI,MAAM;AAAA,EACX,CAAC;AACF;AAGO,MAAM,4BAA4B,CAAC,cAAc,aAAa,aAAa,eAAe;AAE1F,MAAM,4BAA4B,CAAC,aAAa,iBAAiB;AAGxE,eAAsB,cAAc,MAA8B;AACjE,SAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC7C,UAAM,SAAS,IAAI,WAAW;AAC9B,WAAO,UAAU,MAAM,OAAO,OAAO,KAAK;AAC1C,WAAO,SAAS,MAAM;AACrB,cAAQ,OAAO,aAAS,mCAAW,OAAO,MAAqB,IAAI,KAAK;AAAA,IACzE;AACA,WAAO,kBAAkB,IAAI;AAAA,EAC9B,CAAC;AACF;",
  "names": ["containBoxSize"]
}
